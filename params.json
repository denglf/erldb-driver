{"name":"Erldb","tagline":"Linked-in driver of erlang that supports popular RDMBS like mysql, oracle, DB2 and sybase.","body":"## Introduction\r\n\r\nThe db_driver is a high performance database driver based on the Erlang linked-in driver. It uses asynchronous threads to avoid IO block during the database access, the same way in which Erlang asynchronous drivers were implemented. We followed the syntax of Erlydb (erlang_mysql_driver) to design the APIs. For one database access request, the parameters will be passed to driver and processed in asynchronous threads. Then the request will be translated to respective SQL statements for different database types. After that, the work threads will call vendors' C/C++ APIs to execute these SQL statements and return the responses with ei.\r\n\r\nNow the driver supports MySQL, Oracle, Sybase, DB2 and Informix.\r\n\r\n## Design Purpose\r\n\r\nWe want to support most typical database systems, such as Mysql, Oracle, Sybase, DB2 and Informix, but we don't choose ODBC because of its poor performance.\r\n\r\n## Installation\r\nIn the db_driver directory, execute\r\n\r\n```sh\r\n$ ./configure [--with-mysql, --with-oracle, --with-sybase, --with-db2 or --with-informix]\r\n$ make\r\n$ sudo make install\r\n```\r\nOr you can select your drivers in rebar.conf\r\n\r\n```erlang\r\n{drivers, [mysql, oracle]}.\r\n```\r\n\r\nand execute\r\n\r\n```sh\r\n$ ./rebar compile\r\n```\r\n\r\n## Documentation\r\nIn the db_driver directory, execute\r\n\r\n```sh\r\n$ ./make_edoc\r\n$ ./rebar doc\r\n```\r\n\r\nto generate Erlang API.\r\n\r\nThe Database-Driven Documentation generated by doxygen. If you installed\r\ndoxygen, you can execute\r\n\r\n```sh\r\n$ doxygen priv/doc/db.doxyfile\r\n```\r\n\r\nto generated [C API](lib/html/index.html).\r\n\r\nOpen doc/index.html to view the erlang API document.\r\n\r\n## Connection Parameters\r\nTo use db_driver, you need to configure db_driver to make default database\r\nconnection for database-driven start-up. The connection parametes likes:\r\n\r\n```erlang\r\nPoolId = test,\r\nConnArgs =  [{driver, mysql},\r\n             {database, \"test\"},\r\n             {host, \"localhost\"},\r\n             {user, \"root\"},\r\n             {password, \"\"},\r\n             {poolsize, 8}\r\n             ].\r\n```\r\n\r\nwhere PoolId is the name of your connection instance, the type is atom.\r\n\r\nThe following is required parameters.\r\n\r\n```erlang\r\ndriver::atom()          Database type. Supported mysql, oracle and sybase.\r\ndatabase::string()      Database name.\r\nhost::string()          Database host name or IP address.\r\nuser:string()           Database user.\r\npassword:string()       Database password.\r\npoolsize::integer()     Connection pool size.\r\n```\r\n\r\nThe following is optional parameters.\r\n\r\n```erlang\r\nport::integer()             %% Database port. Default is 3306.\r\ndefault_pool::boolean()     %% Default Connection pool.\r\nerror_handler::{Mod, Fun}   %% Callback Function of error handler.\r\n```\r\n\r\n## Getting Started\r\n\r\nStarts db driver\r\n\r\n```erlang\r\n%% Start db driver.\r\ndb_api:start().\r\n\r\n%% Connection instance Id.\r\nPoolId = 'test'.\r\n\r\n%% Connection args.\r\nConnArg = [{driver, mysql},\r\n           {database, \"test\"},\r\n           {host, \"localhost\"},\r\n           {user, \"root\"},\r\n           {password, \"\"},\r\n           {poolsize, 8},\r\n           {default_pool, true}].\r\n\r\n%% Add a connection pool.\r\ndb_api:add_pool(PoolId, ConnArg).\r\n\r\n%% Execute sql string.\r\ndb_api:execute_sql(\"select version()\").\r\n\r\n%% If you didn't set the default pool flag, you can execute sql like this.\r\ndb_api:execute_sql(\"select version()\", [{pool, PoolId}]).\r\n\r\n%% Remove a connecttion pool.\r\ndb_api:remove_pool(PoolId),\r\n\r\n%% Stop db driver.\r\ndb_api:stop().\r\n```\r\n\r\nIf you set the dafault pool flag in several connection pools,\r\nthe default pool is the last added pool.\r\n\r\n## Tests\r\n\r\nSee test cases in module basic_SUITE, module informix_SUITE and module oracle_SUITE.\r\n\r\n## Data Type\r\n\r\nThe following is the mapping of database data type to Erlang data type.\r\n#### MySQL data type.\r\n\r\n```erlang\r\nBIT             integer()\r\nTINYINT         integer()\r\nBOOL, BOOLEAN   integer()\r\nSMALLINT        integer()\r\nMEDIUMINT       integer()\r\nINT             integer()\r\nINTEGER         integer()\r\nBIGINT          integer()\r\nFLOAT           float()\r\nDOUBLE          float()\r\nFLOAT           float()\r\nDECIMAL         float()\r\nDATE            {date, {Year::integer(), Month::integer(), Day::integer()}}\r\nDATETIME        {datetime,\r\n                    {{Year::integer(), Month::integer(), Day::integer()},\r\n                     {Hour::integer(), Minute::integer(), Second::integer()}}}\r\nTIMESTAMP       {datetime,\r\n                    {{Year::integer(), Month::integer(), Day::integer()},\r\n                     {Hour::integer(), Minute::integer(), Second::integer()}}}\r\nTIME            {time, {Hour::integer(), Minute::integer(), Second::integer()}}\r\nYEAR            integer()\r\nCHAR            integer()\r\nVARCHAR         string()\r\nBINARY          string()\r\nVARBINARY       string()\r\nTINYBLOB        binary()\r\nTINYTEXT        string()\r\nBLOB            binary()\r\nTEXT            string()\r\nMEDIUMBLOB      binary()\r\nMEDIUMTEXT      string()\r\nLONGBLOB        binary()\r\nLONGTEXT        string()\r\n```\r\n#### Oracle data type.\r\n\r\n```erlang\r\nSTRING          string()\r\nNUMBER          number()\r\nDATE            {datetime,\r\n                    {{Year::integer(), Month::integer(), Day::integer()},\r\n                     {Hour::integer(), Minute::integer(), Second::integer()}}}\r\nTIMESTAMP       {timestamp,\r\n                    {{Year::integer(), Month::integer(), Day::integer()},\r\n                     {Hour::integer(),\r\n                      Minute::integer(),\r\n                      Second::integer(),\r\n                      Microseconds::integer()},\r\n                     {TimeZoneOffsetInHours::integer(),\r\n                      TimeZoneOffsetInMinutes::integer()}}}\r\nTIMESTAMP_Z     {timestamp,\r\n                    {{Year::integer(), Month::integer(), Day::integer()},\r\n                     {Hour::integer(),\r\n                      Minute::integer(),\r\n                      Second::integer(),\r\n                      Microseconds::integer()},\r\n                     {TimeZoneOffsetInHours::integer(),\r\n                      TimeZoneOffsetInMinutes::integer()}}}\r\nTIMESTAMP_LZ    {timestamp,\r\n                    {{Year::integer(), Month::integer(), Day::integer()},\r\n                     {Hour::integer(),\r\n                      Minute::integer(),\r\n                      Second::integer(),\r\n                      Microseconds::integer()},\r\n                     {TimeZoneOffsetInHours::integer(),\r\n                      TimeZoneOffsetInMinutes::integer()}}}\r\nBINARY          binary()\r\nCLOB            string()\r\nNCLOB           string()\r\nBLOB            binary()\r\nINTERVAL_YM     {interval_ym, {Year::integer(), Month::integer()}}}\r\nINTERVAL_DS     {interval_ds,\r\n                    {Day::integer(),\r\n                     Hour::integer(),\r\n                     Minute::integer(),\r\n                     Second::integer(),\r\n                     FractionalSecondComponent::integer()}}\r\n```\r\n#### Sybase data type.\r\n\r\n```erlang\r\nVARBINARY       binary()\r\nBIT             integer()\r\nCHAR            string()\r\nVARCHAR         string()\r\nUNICHAR         list()\r\nUNIVARCHAR      list()\r\nDATE            {date, {Year::integer(), Month::integer(), Day::integer()}}\r\nTIME            {time,\r\n                    {Hour::integer(),\r\n                     Minute::integer(),\r\n                     Second::integer(),\r\n                     Millisecond::integer()}}\r\nDATETIME        {datetime,\r\n                    {{Year::integer(), Month::integer(), Day::integer()},\r\n                     {Hour::integer(),\r\n                      Minute::integer(),\r\n                      Second::integer(),\r\n                      Millisecond::integer()}}}\r\nSMALLDATETIME   {smalldatetime,\r\n                    {{Year::integer(), Month::integer(), Day::integer()},\r\n                     {Hour::integer(), Minute::integer()}}}\r\nTINYINT         integer()\r\nSMALLINT        integer()\r\nINT             integer()\r\nBIGINT          integer()\r\nDECIMAL         {number, string()}\r\nNUMERIC         {number, string()}\r\nFLOAT           float()\r\nREAL            float()\r\nMONEY           {number, string()}\r\nSMALLMONEY      float()\r\n```\r\n## Query Description\r\n### Supported Keyword\r\nThe following keywords are supported (mainly used in the select):\r\n\r\n```\r\ntable: 'join', 'left, join', 'right, join', 'inner, join'.\r\nfields: 'as', '+', '-', '*', '/', '.', 'function'.\r\nwhere: 'and', 'or', 'not', 'like', 'between', 'in', '+', '-', '*', '/', '=', '!=', '>', '>=', '<', '<=', '.', 'function'.\r\nextras: 'order', 'asc', 'desc', 'limit', 'group', 'having', 'and', 'or', 'not', 'like', 'between', 'in', '+', '-', '*', '/', '=', '!=', '>', '>=', '<', '<=', '.', 'function'.\r\n```\r\n### Insert Field Type Description\r\ninsert function description:\r\n\r\n```erlang\r\ninsert(Table::atom(), [{Field::atom(), Value::term()}]).\r\n```\r\nCreate table test1, \"f + Data Types\" as the field name, the sample insert statement is as follows:\r\n\r\n```erlang\r\ndb_api:insert(test1, [\r\n        {fbit, 1},\r\n        {ftinyint, 1},\r\n        {fsmallint, 200},\r\n        {fmediunint, 1323},\r\n        {fint, 38524},\r\n        {fbigint, 2233434},\r\n        {ffloat, 238954.345},\r\n        {fdouble, 335623.276212},\r\n        {fdecimal, 45656.12},\r\n        {fdate, {date, {2010, 3, 24}}},\r\n        {fdatetime, {datetime, {{2010, 3, 24}, {11, 19, 30}}}},\r\n        {ftimestamp, {datetime, {{2010, 3, 1}, {2, 10, 30}}}},\r\n        {ftime, {time, {11, 45, 22}}},\r\n        {fyear, 2010},\r\n        {fchar, 97},\r\n        {fvarchar, \"test varchar\"},\r\n        {fbinary, \"fjdsgjnkdgbdf dfdfg\\r\\n isfdk\"},\r\n        {fvarbinary, \"dkjsor klsjfsdfj\"},\r\n        {ftinytext, \"dsfgd\"},\r\n        {ftext, \";ljkdf\"},\r\n        {fmediumtext, \"dfuyejksf\"},\r\n        {flongtext, \"indtvdf\"},\r\n        {ftinyblob, <<\"hg\">>},\r\n        {fblob, <<34,56,0,54,75>>},\r\n        {fmediumblob, <<97,98,99,100>>},\r\n        {flongblob, <<\"sdfidsigyrertkjhejkrgweur3[5940766%^#$^&(;lgf khjfgh\">>}\r\n]).\r\n```\r\n### Where Clause Syntax Description\r\n#### Comparison Operators\r\n\r\n```erlang\r\n{field, '=', WhereExpr}\r\n{field, '!=', WhereExpr}\r\n{field, '>=', WhereExpr}\r\n{field, '<=', WhereExpr}\r\n```\r\n\r\n#### '+', '-', '*', '/'\r\n\r\n```erlang\r\n{WhereExpr1, '+', WhereExpr2}\r\n{WhereExpr1, '-', WhereExpr2}\r\n{WhereExpr1, '*', WhereExpr2}\r\n{WhereExpr1, '/', WhereExpr2}\r\n```\r\n\r\n#### AND\r\n```erlang\r\n{'and', [WhereExpr]}\r\n```\r\n#### OR\r\n```erlang\r\n{WhereExpr, 'or', WhereExpr}\r\n```\r\n#### NOT\r\n```erlang\r\n{'not', WhereExpr}\r\n```\r\n#### LINK\r\n```erlang\r\n{WhereExpr, 'like', WhereExpr}\r\n```\r\n#### BETWEEN\r\n```erlang\r\n{WhereExpr, 'between', {WhereExpr1, WhereExpr2}}\r\n```\r\n#### IN\r\n```erlang\r\n{WhereExpr1, 'in', [WhereExpr2]}\r\n```\r\n#### AS\r\n```erlang\r\n{WhereExpr1, 'as', WhereExpr2}\r\n```\r\nExample:\r\n```erlang\r\ndb_api:select(test1,\r\n    {'and', [{fint, '>', 10}, {fdate, '=', {date, {2010, 3, 24}}}]})\r\n```\r\n### Option Syntax Description\r\n#### pool\r\nDatabase connection pool.\r\n\r\n```erlang\r\n{pool, pool_name}\r\n```\r\n#### fields\r\nselect list of fields returned.\r\n\r\n```erlang\r\n{fields, [id, name]}\r\n```\r\n#### distinct\r\nMysql syntax similar to the distinct , whether to remove duplicate records. The default is false.\r\n\r\n```erlang\r\n{distinct, true}\r\n```\r\n#### extras\r\nExpand list.\r\n\r\n```erlang\r\n{extras, [{order, name}, {limit, 1}, {group, name}]}\r\n```\r\n*order*\r\n\r\nOrdering the results.\r\n\r\n```erlang\r\n{order, Field}\r\n{order, {Field, asc}}\r\n{order, {Field, desc}}\r\n{order, [{Field1, asc}, {Field2, desc}]}\r\n```\r\n*limit*\r\n\r\nLimit the number of records.\r\n\r\n```erlang\r\n{limit, 10}\r\n{limit, 10, 20}\r\n```\r\n*group*\r\n\r\nThe result set grouping.\r\n\r\n```erlang\r\n{group, name}\r\n{group, [id, name]}\r\n```\r\n\r\n*having*\r\n\r\nThe result set grouping condition.\r\n\r\n```erlang\r\n{having, {fint, '>', 5}}\r\n```\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}